1
00:00:01,088 --> 00:00:04,509
字幕组：赵含霖 谢鑫鑫

2
00:00:06,811 --> 00:00:10,267
Hello,大家好,欢迎来到ZOMI的课堂

3
00:00:10,950 --> 00:00:12,858
这是自动微分的第二节

4
00:00:12,858 --> 00:00:14,600
微分的基本概念

5
00:00:15,973 --> 00:00:18,126
微分对AI框架来说非常重要

6
00:00:18,126 --> 00:00:20,588
但是微分的方式有很多种

7
00:00:20,588 --> 00:00:22,588
或者微分的概念非常多

8
00:00:22,908 --> 00:00:27,000
其中最主要的就是数字微分、符号微分和自动微分
9
00:00:27,000 --> 00:00:30,277
而自动微分就是今天的主角

10
00:00:42,000 --> 00:00:45,250
在正式进入到内容里面

11
00:00:45,250 --> 00:00:47,540
我给大家推荐几个阅读材料

12
00:00:48,025 --> 00:00:51,315
在机器学习当中的一个自动微分的综述

13
00:00:51,800 --> 00:00:55,693
今天所讲的所有的内容主要是来自于这篇文章

14
00:00:55,693 --> 00:00:57,852
所以大家也可以去看一下

15
00:00:58,650 --> 00:01:01,368
第二篇推荐的就是Tangent

16
00:01:01,368 --> 00:01:05,550
是谷歌在16年、17年到18年发起的一个项目

17
00:01:05,875 --> 00:01:10,032
不过因为各种原因,这个项目最后流产了

18
00:01:10,425 --> 00:01:12,272
这个后面也会讲到

19
00:01:12,272 --> 00:01:16,112
它是基于源码转换实现的一个自动微分的方式

20
00:01:16,596 --> 00:01:20,493
第三篇文章是基于神经网络张量的

21
00:01:20,493 --> 00:01:23,416
一个自动微分编程的方式

22
00:01:24,552 --> 00:01:27,752
还有最后一篇就是δP

23
00:01:27,752 --> 00:01:33,050
一个在机器学习和科学计算的自动微分编程的系统

24
00:01:33,993 --> 00:01:36,425
这四篇文章都非常值得去参考
25
00:01:38,000 --> 00:01:40,944
回到今天的课程里面

26
00:01:40,944 --> 00:01:42,986
现在有三条公式

27
00:01:42,986 --> 00:01:45,788
第一条公式就是L(1)等于X

28
00:01:45,788 --> 00:01:47,964
现在有定义第二条公式

29
00:01:47,964 --> 00:01:52,390
L(n+1)等于4L(n)(1-L(1))

30
00:01:52,390 --> 00:01:54,834
假设N等于4的时候

31
00:01:54,834 --> 00:01:58,325
手工地求解微分

32
00:01:58,325 --> 00:02:00,473
可以发现根据链式求导法则

33
00:02:00,473 --> 00:02:07,064
微分的一个计算公式就变得非常非常的长了

34
00:02:07,550 --> 00:02:10,750
长到这个等号后面非常非常的多

35
00:02:11,100 --> 00:02:14,130
而这个呢,叫做手工微分

36
00:02:14,130 --> 00:02:18,775
手工微分就是人工地去计算微分公式

37
00:02:18,775 --> 00:02:21,529
所以就变成这么去编写

38
00:02:21,529 --> 00:02:22,873
在实际的计算机里面

39
00:02:22,873 --> 00:02:26,456
就会去写很多非常冗余的东西

40
00:02:26,456 --> 00:02:29,784
如果表达是不可知或者越来越复杂的时候

41
00:02:29,784 --> 00:02:32,464
不可能每一次都手工的去求一遍吧

42
00:02:32,464 --> 00:02:36,732
所以就会引入计算机实现的几种微分方式

43
00:02:37,156 --> 00:02:39,012
第一种就是符号微分

44
00:02:39,012 --> 00:02:41,181
第二种就是数值微分

45
00:02:41,181 --> 00:02:43,256
第三种是自动微分

46
00:02:43,649 --> 00:02:46,648
等一下会重新回到这三种微分

47
00:02:46,648 --> 00:02:49,609
来去统一看一看有什么区别

48
00:02:50,286 --> 00:02:53,052
现在来看看刚才所讲的三条公式

49
00:02:53,052 --> 00:02:54,268
手动地去编写

50
00:02:55,050 --> 00:02:58,472
f(x)呢V等于X就是对应第一条公式

51
00:02:58,472 --> 00:03:03,976
然后V等于4*V*(1-V)就是对应第二条公式

52
00:03:03,976 --> 00:03:06,472
然后去返回V

53
00:03:06,472 --> 00:03:08,836
这个就是正向的一个计算

54
00:03:08,836 --> 00:03:12,484
f(x)等于4的时候,可能就会返回这么一条公式

55
00:03:12,484 --> 00:03:14,117
这个是正向的

56
00:03:14,117 --> 00:03:18,552
符号微分就需要人工地去展开这么一个复杂的内容

57
00:03:18,858 --> 00:03:22,161
数值微分呢就是设定一个很小的数

58
00:03:22,161 --> 00:03:24,570
然后用差分的方式去求解

59
00:03:24,570 --> 00:03:30,202
而自动微分呢就是把v和δv一起给计算机去求解

60
00:03:31,875 --> 00:03:34,048
首先要理清楚一个概念

61
00:03:34,650 --> 00:03:37,838
自动微分并不是符号微分

62
00:03:38,083 --> 00:03:40,890
符号微分也实现不了自动微分

63
00:03:40,890 --> 00:03:43,112
那看看什么是符号微分

64
00:03:43,112 --> 00:03:49,057
符号微分说白了就是通过求导法则对公式进行展开

65
00:03:49,625 --> 00:03:53,829
下面呢就是两个复式求导法则的大原则

66
00:03:53,829 --> 00:03:55,341
根据这个大原则

67
00:03:55,341 --> 00:03:58,474
对原始的表达式进行展开

68
00:03:58,794 --> 00:04:03,188
可以看到通过对原始表达式展开求导

69
00:04:03,667 --> 00:04:06,262
表达式就会急剧地膨胀了

70
00:04:06,262 --> 00:04:09,246
所以呢它的缺点非常明显

71
00:04:09,246 --> 00:04:10,718
就是表达式膨胀

72
00:04:11,118 --> 00:04:13,153
每次都要人工地去算一遍

73
00:04:13,153 --> 00:04:18,045
但是优势呢就是计算的数值非常精确

74
00:04:18,365 --> 00:04:23,049
因为每一步都是正确地通过求导法则计算得到的

75
00:04:23,475 --> 00:04:25,264
这个就是符号微分

76
00:04:25,456 --> 00:04:27,678
那看一下数值微分

77
00:04:27,678 --> 00:04:30,360
再重新强调一下啊

78
00:04:30,360 --> 00:04:33,218
自动微分并不是数值微分

79
00:04:33,218 --> 00:04:34,933
也不是符号微分

80
00:04:34,933 --> 00:04:38,332
数值微分最简单的原理通俗来讲就是

81
00:04:38,332 --> 00:04:41,029
使用有限差分进行计算

82
00:04:41,300 --> 00:04:43,768
首先所谓的有限差分就是

83
00:04:43,960 --> 00:04:46,392
模拟一个很小的数h

84
00:04:46,392 --> 00:04:50,340
h是大于0但是无限接近0的一个数

85
00:04:50,340 --> 00:04:52,770
求f(x)关于x的导数呢

86
00:04:54,025 --> 00:04:57,461
最简单的就是可以用差分的方式进行求解

87
00:04:57,711 --> 00:05:03,849
把f(x)加上一个很小的数再减去f(x)再除以h

88
00:05:03,849 --> 00:05:10,686
就求得了在函数在某个点的变化趋势

89
00:05:11,006 --> 00:05:14,526
这个就是求数值微分的方式

90
00:05:14,850 --> 00:05:18,306
这种方式的优势就是非常容易实现

91
00:05:18,306 --> 00:05:23,170
可以看到实现这个公式在计算机里面非常简单

92
00:05:23,170 --> 00:05:24,386
但是要记住

93
00:05:24,706 --> 00:05:27,393
在计算机里面经常会遇到

94
00:05:27,393 --> 00:05:33,674
fp32、int8、fp16或者fp64这种不同精度的

95
00:05:34,159 --> 00:05:37,450
因为硬件所设计的一些格式

96
00:05:38,434 --> 00:05:40,389
那有这种格式呢

97
00:05:40,389 --> 00:05:43,700
就可能导致计算结果不精确

98
00:05:44,020 --> 00:05:48,052
计算复杂度高或者对h的要求高

99
00:05:48,436 --> 00:05:51,605
h用int8能表达吗？应该不能！

100
00:05:51,605 --> 00:05:53,004
因为它是一个非常小的小数

101
00:05:53,260 --> 00:05:56,977
fp16呢？fp16不够还有fp32

102
00:05:56,977 --> 00:06:00,044
fp32不够小还有fp64

103
00:06:00,044 --> 00:06:02,470
但是它真的够精确了吗？

104
00:06:09,825 --> 00:06:13,930
都不够精确！因为这里是个≈符号哦

105
00:06:14,825 --> 00:06:19,477
当我的计算结果不够精确的时候就会引起两个误差

106
00:06:19,477 --> 00:06:21,213
第一个叫做Truncation Error

107
00:06:21,213 --> 00:06:26,441
假设 我的数是3.1415926吗？

108
00:06:26,700 --> 00:06:28,848
这不是Π

109
00:06:28,848 --> 00:06:33,318
那我就需要对后面的数据进行截断

110
00:06:33,318 --> 00:06:35,717
那截断之后就引起另外一个问题了

111
00:06:35,717 --> 00:06:40,060
就是我的这个数需要怎么去舍入呢

112
00:06:40,060 --> 00:06:43,430
我舍入了是要进一位呢还是要退一位呢

113
00:06:43,430 --> 00:06:45,430
就引起了舍入误差了

114
00:06:45,430 --> 00:06:47,197
叫做Round-off Error

115
00:06:47,517 --> 00:06:50,001
第二个计算复杂度高

116
00:06:50,205 --> 00:06:54,173
这个就会阻碍在机器学习领域的发展了

117
00:06:54,173 --> 00:06:57,308
因为每一个都要去计算

118
00:06:57,308 --> 00:07:01,868
0.000...x这么小的小数的时候

119
00:07:01,868 --> 00:07:05,525
在机器学习里面大量的使用fp32进行计算

120
00:07:05,525 --> 00:07:08,449
这个时候就非常不利于发展了

121
00:07:09,650 --> 00:07:15,334
下面呢来看看什么是真正的自动微分

122
00:07:15,817 --> 00:07:20,681
回到这里面不要去看下面两个黑色的框

123
00:07:20,925 --> 00:07:24,169
跟这个视频的主题呢没有太多的关系

124
00:07:24,169 --> 00:07:28,298
会在后面正式地去实现的时候给大家展示代码的

125
00:07:28,298 --> 00:07:30,730
先来聊聊数学原理

126
00:07:30,730 --> 00:07:38,666
自动微分是指所有的数值计算都由有限的基本运算组成

127
00:07:38,666 --> 00:07:46,574
也就是由基本的+、-、*、/、√、²等基本运算组成的

128
00:07:47,022 --> 00:07:51,043
第二点就是这些基本运算的导数表达式是已知的

129
00:07:51,043 --> 00:07:56,227
也就是a+b的导数是能够知道的

130
00:07:56,734 --> 00:07:59,713
然后a-b的导数也是能够知道的

131
00:07:59,713 --> 00:08:01,713
就是基本运算的导数

132
00:08:01,713 --> 00:08:04,265
由这些已知的才能够

133
00:08:04,265 --> 00:08:09,806
通过链式求导法则将数值计算各部分组合成整体

134
00:08:09,806 --> 00:08:13,886
计算机最擅长的就是做组合、做系统

135
00:08:13,886 --> 00:08:14,846
就是做迭代

136
00:08:15,230 --> 00:08:19,749
所以利用这个特性发明了自动微分功能

137
00:08:21,125 --> 00:08:24,389
下面来看看在神经网络里面呢

138
00:08:24,389 --> 00:08:27,944
要实现自动微分有一个概念非常重要

139
00:08:27,944 --> 00:08:29,730
就是表达式追踪

140
00:08:29,730 --> 00:08:32,137
叫做Evaluation Trace

141
00:08:32,137 --> 00:08:36,041
就是追踪数值计算过程中的中间变量

142
00:08:36,457 --> 00:08:38,457
那什么是中间变量呢？

143
00:08:38,457 --> 00:08:43,430
假设这里有三个算子或三个计算

144
00:08:43,430 --> 00:08:45,030
第一个呢就是卷积

145
00:08:45,030 --> 00:08:47,309
第二个就是激活层Relu

146
00:08:47,309 --> 00:08:49,357
第三个就是求Loss的

147
00:08:49,675 --> 00:08:52,232
这个是一个正向的计算方式啊

148
00:08:52,232 --> 00:08:55,816
输入是一个Tensor

149
00:08:55,816 --> 00:08:59,453
然后w、b是卷积的一个权重

150
00:08:59,453 --> 00:09:03,470
在正向计算的时候其实没有太多的问题

151
00:09:03,470 --> 00:09:06,118
但是看看反向的过程当中啊

152
00:09:06,168 --> 00:09:08,472
右边那个图呢就变得非常复杂了

153
00:09:08,544 --> 00:09:10,208
这个是正向的，这个是反向的

154
00:09:10,720 --> 00:09:13,364
从正向到反向没有这么简单

155
00:09:13,364 --> 00:09:16,486
会引申右边的一部分

156
00:09:16,767 --> 00:09:19,938
就是每一个计算、每一个公式

157
00:09:19,938 --> 00:09:23,617
反向的时候呢都会引入大量的变量

158
00:09:23,617 --> 00:09:27,521
这个时候做自动微分就是由表达式追踪

159
00:09:27,521 --> 00:09:30,977
通过Trace跟踪每个计算

160
00:09:30,977 --> 00:09:35,150
就是每一根箭头都需要跟踪

161
00:09:35,214 --> 00:09:39,874
如果不跟踪那么计算什么、下一次传导什么

162
00:09:39,874 --> 00:09:42,904
哪一次要复用前面的w

163
00:09:42,904 --> 00:09:45,432
哪一次要调用dw都不知道了

164
00:09:46,136 --> 00:09:47,918
回到这个图可以看到

165
00:09:47,918 --> 00:09:50,560
实际上符号微分很简单

166
00:09:51,306 --> 00:09:55,465
只是通过链式求导法则对公式进行组合

167
00:09:56,169 --> 00:09:58,921
数值微分也很简单

168
00:09:59,700 --> 00:10:04,052
设一个很小的数然后根据这条公式去计算

169
00:10:04,244 --> 00:10:07,566
而实际上今天讨论的自动微分呢

170
00:10:07,566 --> 00:10:09,614
就是通过计算机系统

171
00:10:09,614 --> 00:10:11,614
通过表达式追踪

172
00:10:11,653 --> 00:10:16,085
去跟踪每一次求导的公式和方程

173
00:10:17,301 --> 00:10:19,540
今天的课程到这里就结束了

174
00:10:19,775 --> 00:10:23,444
今天了解了计算机微分的三种形态

175
00:10:23,444 --> 00:10:25,044
第一种就是符号微分

176
00:10:25,044 --> 00:10:27,857
第二种数值微分、第三种自动微分

177
00:10:28,241 --> 00:10:31,182
还了解了符号微分的基本原理和优缺点

178
00:10:31,182 --> 00:10:33,668
还有数值微分的基本原理和优缺点

179
00:10:34,306 --> 00:10:39,095
最后还讨论了自动微分基本原理

180
00:10:39,095 --> 00:10:40,887
但是没有太展开

181
00:10:41,125 --> 00:10:45,073
自动微分将在下一节详细地展开

182
00:10:45,117 --> 00:10:47,117
这里面只是抛出一个概念

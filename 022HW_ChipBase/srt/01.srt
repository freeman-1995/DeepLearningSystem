1
00:00:00,000 --> 00:00:05,700
字幕校对:米哈游天下第一

2
00:00:05,700 --> 00:00:11,475
哈喽,大家好,问君能有几多愁,未到三旬又秃头的ZOMI

3
00:00:11,500 --> 00:00:17,200
来到通用处理器 CPU 这一个章节内容

4
00:00:17,200 --> 00:00:21,200
今天回顾一下在整个 AI 芯片基础里面

5
00:00:21,200 --> 00:00:24,200
会从 CPU 到 GPU 再到 NPU

6
00:00:24,200 --> 00:00:27,700
然后再到了计算体系架构的黄金十年

7
00:00:27,700 --> 00:00:29,700
也就是超异构体系里面

8
00:00:30,400 --> 00:00:34,000
现在还是在通用处理器 CPU 这个内容

9
00:00:34,000 --> 00:00:35,500
这个内容可能会稍微有点多

10
00:00:35,500 --> 00:00:39,700
我会分开两个视频给大家去汇报的

11
00:00:39,700 --> 00:00:42,200
首先在今天我要去汇报一下

12
00:00:42,200 --> 00:00:44,700
CPU 的整体的发展历史和组成

13
00:00:44,700 --> 00:00:47,500
还有 CPU 的并行处理的架构

14
00:00:47,500 --> 00:00:51,500
现在开始第一个内容就是 CPU 的发展历史

15
00:00:51,500 --> 00:00:53,200
还有它的组成

16
00:00:53,200 --> 00:00:55,200
从发展去看它的组成

17
00:00:56,200 --> 00:01:00,200
其实世界上的第一台真正意义的计算机

18
00:01:00,200 --> 00:01:02,200
是在 1946 年的时候

19
00:01:02,200 --> 00:01:04,700
美国宾夕法利亚大学投入运行的

20
00:01:04,700 --> 00:01:07,200
当时候采用的还不是二进制

21
00:01:07,200 --> 00:01:09,200
而是十进制的数据进行处理

22
00:01:09,200 --> 00:01:11,175
那这台计算机叫做

23
00:01:11,175 --> 00:01:11,200
ENIAC 电子数字积分计算机

24
00:01:11,200 --> 00:01:14,175
ENIAC 电子数字积分计算机

25
00:01:14,200 --> 00:01:19,200
不知道大家认不认识里面的这两位美女

26
00:01:19,200 --> 00:01:23,200
现在看看世界第一台二进制的计算器

27
00:01:23,200 --> 00:01:26,200
那这台计算机其实是由冯诺依曼

28
00:01:26,200 --> 00:01:30,200
或者冯诺依曼教授去发明的

29
00:01:30,200 --> 00:01:35,200
名字叫做 EDVC 电子离散变量的自动计算机

30
00:01:35,200 --> 00:01:38,200
这里面提到冯诺依曼就很有意思了

31
00:01:38,200 --> 00:01:40,150
通过这一台计算机

32
00:01:40,150 --> 00:01:40,200
冯诺依曼就提出了他经典的冯诺依曼架构

33
00:01:40,200 --> 00:01:43,150
冯诺依曼就提出了他经典的冯诺依曼架构

34
00:01:43,200 --> 00:01:46,200
由运算器、控制器、存储器还有输出

35
00:01:46,200 --> 00:01:49,200
就是 IO 五个部分去组成

36
00:01:49,200 --> 00:01:51,200
那聊到计算机的发展历史

37
00:01:51,200 --> 00:01:53,200
就离不开计算机的组成

38
00:01:53,200 --> 00:01:55,200
直到现今为止

39
00:01:55,200 --> 00:01:59,200
无论 CPU 经过了多少代的变化

40
00:01:59,200 --> 00:02:01,200
或者晶体管的数量翻了多少番

41
00:02:01,200 --> 00:02:04,200
它的整个的组成或者构成

42
00:02:04,200 --> 00:02:05,200
有五个部分组成

43
00:02:05,200 --> 00:02:07,200
第一个就是输出、输入

44
00:02:07,200 --> 00:02:09,200
那这个可以避而不谈

45
00:02:09,200 --> 00:02:11,200
最重要的就是中间三部分

46
00:02:11,200 --> 00:02:15,200
控制单元、计算单元、ALU 还有内存单元

47
00:02:15,200 --> 00:02:20,200
通过这三个部分来组成整个 CPU 的最重要的核心内容

48
00:02:20,200 --> 00:02:22,200
中央控制处理器

49
00:02:22,200 --> 00:02:26,200
当然这里面其实只是一个简图

50
00:02:26,200 --> 00:02:28,200
实际上中央处理单元

51
00:02:28,200 --> 00:02:31,200
它的整个连线、整个 IO

52
00:02:31,200 --> 00:02:34,200
整个具体的控制流程是非常的复杂的

53
00:02:34,200 --> 00:02:36,200
接着往下看一看

54
00:02:36,200 --> 00:02:39,200
这些单元之间是怎么互相配合的

55
00:02:39,200 --> 00:02:42,200
第一个内容叫做运算器

56
00:02:42,200 --> 00:02:44,200
运算器叫做 ALU

57
00:02:44,200 --> 00:02:46,200
也叫做算术逻辑单元

58
00:02:46,200 --> 00:02:49,200
主要是负责算术的运算和逻辑的运算

59
00:02:49,200 --> 00:02:52,200
什么叫做算术运算和逻辑运算呢?

60
00:02:52,200 --> 00:02:53,200
简单的来说

61
00:02:53,200 --> 00:02:56,200
算术运算就是加减乘除

62
00:02:56,200 --> 00:03:00,200
逻辑运算就是与 或 非 异或这些内容

63
00:03:00,200 --> 00:03:03,200
输进去有可能有两个数据

64
00:03:03,200 --> 00:03:06,200
然后输出来的是一个数据

65
00:03:06,200 --> 00:03:08,200
中间还穿插一些状态码

66
00:03:08,200 --> 00:03:10,200
这个就是运算器了

67
00:03:10,200 --> 00:03:15,200
而整体的运算器也是由逻辑控制门来去组成的

68
00:03:15,200 --> 00:03:17,200
接着看看第二个内容

69
00:03:17,200 --> 00:03:19,200
寄存器

70
00:03:19,200 --> 00:03:23,200
寄存器其实分为指令寄存器和数据寄存器

71
00:03:23,200 --> 00:03:25,200
主要是两种负责一些

72
00:03:25,200 --> 00:03:26,200
暂存指令

73
00:03:26,200 --> 00:03:27,200
command

74
00:03:27,200 --> 00:03:29,200
还有ALU的一些操作

75
00:03:29,200 --> 00:03:31,200
ALU算出来的结果

76
00:03:31,200 --> 00:03:33,200
往左边看一下

77
00:03:33,200 --> 00:03:37,200
整个寄存器可以有非常多不同的寄存器

78
00:03:37,200 --> 00:03:40,200
有指令寄存器、地址寄存器、累积寄存器、编程寄存器

79
00:03:40,200 --> 00:03:46,200
而很多时候完全这些寄存器是由控制单元去控制

80
00:03:46,200 --> 00:03:47,200
它什么时候存什么

81
00:03:47,200 --> 00:03:49,200
什么时候发生什么作用

82
00:03:49,200 --> 00:03:53,200
最后控制单元根据寄存器的内容

83
00:03:53,200 --> 00:03:56,200
下发到运算器ALU里面

84
00:03:56,200 --> 00:03:59,200
那往右边的这个图举两个简单的例子

85
00:03:59,200 --> 00:04:01,200
首先数据寄存器

86
00:04:01,200 --> 00:04:02,200
叫做DR

87
00:04:02,200 --> 00:04:04,200
它的bit位宽是16位

88
00:04:04,200 --> 00:04:06,200
主要是存储一些临时的指令

89
00:04:06,200 --> 00:04:09,200
可以看到有非常多不同的寄存器

90
00:04:09,200 --> 00:04:10,200
不同的寄存器

91
00:04:10,200 --> 00:04:12,200
它有自己不同的作用

92
00:04:12,200 --> 00:04:13,200
也有不同的位宽

93
00:04:13,200 --> 00:04:16,200
还有自己不同的一个符号位表示

94
00:04:17,200 --> 00:04:19,200
往下看就是最重要的一个功能

95
00:04:19,200 --> 00:04:22,200
控制器负责整体的调度的工作

96
00:04:22,200 --> 00:04:25,200
包括对刚才的一些指令进行一个编码、解码

97
00:04:25,200 --> 00:04:28,200
然后从内存里面把数据读取出来

98
00:04:28,200 --> 00:04:29,200
给到寄存器

99
00:04:29,200 --> 00:04:33,200
然后向一些运算器ALU或者寄存器

100
00:04:33,200 --> 00:04:35,200
发出具体的指令操作

101
00:04:35,200 --> 00:04:36,200
那这个就是控制器

102
00:04:36,200 --> 00:04:38,200
也相当于整个CPU的大脑

103
00:04:38,200 --> 00:04:41,200
所以可以说CPU里面非常核心的一块

104
00:04:41,200 --> 00:04:44,200
就是控制单元控制器

105
00:04:44,200 --> 00:04:47,200
接下来看一下整个CPU的工作流程

106
00:04:47,200 --> 00:04:48,200
就是它的workflow

107
00:04:48,200 --> 00:04:50,200
首先主要分开为四步

108
00:04:50,200 --> 00:04:53,200
刚才讲到了很重要的就是三个内容

109
00:04:53,200 --> 00:04:56,200
控制单元、计算单元还有内存

110
00:04:56,200 --> 00:04:59,200
那第一步就是从内存里面去读取一些指令

111
00:04:59,200 --> 00:05:01,200
给到控制单元

112
00:05:01,200 --> 00:05:02,200
控制单元就会进行

113
00:05:02,200 --> 00:05:05,200
对刚才读取的一些指令来进行解码

114
00:05:05,200 --> 00:05:08,200
变成正式的一些command命令

115
00:05:08,200 --> 00:05:12,200
然后ALU就会去执行这些command这些命令

116
00:05:12,200 --> 00:05:15,200
执行完之后就会存储回来内存

117
00:05:15,200 --> 00:05:17,200
汇总起来就是这四步

118
00:05:17,200 --> 00:05:21,200
内存里面读取指令、解码、执行、写回

119
00:05:21,200 --> 00:05:23,200
就是这四个工作流程

120
00:05:24,200 --> 00:05:27,170
接下来以下面这个代码例子

121
00:05:27,170 --> 00:05:30,200
ax+y（误）这么简单的一个线性操作

122
00:05:30,200 --> 00:05:33,200
看看CPU的三大组成是怎么分工的

123
00:05:33,200 --> 00:05:35,200
那现在可以看到

124
00:05:35,200 --> 00:05:37,200
其实里面的double alpha

125
00:05:37,200 --> 00:05:39,200
这个就是存储

126
00:05:39,200 --> 00:05:41,200
double x也是存储

127
00:05:41,200 --> 00:05:43,200
double y也是存储

128
00:05:43,200 --> 00:05:45,200
包括n等于2000（误）

129
00:05:45,200 --> 00:05:47,200
Int i等于0

130
00:05:47,200 --> 00:05:49,200
这些都是内存

131
00:05:49,200 --> 00:05:51,200
把数据存储起来的

132
00:05:51,200 --> 00:05:53,200
接着控制器就会去内存里面

133
00:05:53,200 --> 00:05:56,200
把刚才这些数据都读取出来

134
00:05:56,200 --> 00:05:57,200
读取出来之后

135
00:05:57,200 --> 00:05:59,200
真正的去运行的

136
00:05:59,200 --> 00:06:02,200
其实只有这个*和+

137
00:06:02,200 --> 00:06:04,200
就是ALU真正运行的

138
00:06:04,200 --> 00:06:05,200
就这么两个操作

139
00:06:05,200 --> 00:06:07,200
而这里面的For循环迭代

140
00:06:07,200 --> 00:06:09,200
什么时候i++

141
00:06:09,200 --> 00:06:11,200
什么时候去相乘

142
00:06:11,200 --> 00:06:12,200
什么时候相加

143
00:06:12,200 --> 00:06:15,200
全都是由控制器去组成的

144
00:06:15,200 --> 00:06:16,200
所以可以说

145
00:06:16,200 --> 00:06:18,200
控制器和寄存器

146
00:06:18,200 --> 00:06:20,200
负责的工作是最多的

147
00:06:20,200 --> 00:06:21,200
要存储的数据

148
00:06:21,200 --> 00:06:23,200
也是最多的两个部分

149
00:06:23,200 --> 00:06:25,200
因为刚才虽然说

150
00:06:25,200 --> 00:06:27,200
这些数据都是从内存里面读出来

151
00:06:27,200 --> 00:06:29,200
但实际在运行之前

152
00:06:29,200 --> 00:06:31,200
控制器会把这些数据

153
00:06:31,200 --> 00:06:33,200
搬到寄存器里面

154
00:06:33,200 --> 00:06:35,200
然后再给ALU去执行

155
00:06:35,200 --> 00:06:36,200
这里面可以看到

156
00:06:36,200 --> 00:06:37,200
大量的数据交互

157
00:06:37,200 --> 00:06:39,200
大量的控制逻辑

158
00:06:39,200 --> 00:06:43,200
而真正的计算只有*和+两个

159
00:06:43,200 --> 00:06:45,200
下面回到中央处理器

160
00:06:45,200 --> 00:06:48,200
这个图可能稍微比刚才那个图

161
00:06:48,200 --> 00:06:50,200
多了一行寄存器

162
00:06:50,200 --> 00:06:52,200
就是因为刚才讲到了

163
00:06:52,200 --> 00:06:54,200
控制单元、计算单元、内存

164
00:06:54,200 --> 00:06:56,200
实际上有寄存器

165
00:06:56,200 --> 00:06:57,200
在真正执行的时候

166
00:06:57,200 --> 00:07:00,200
就会把内存的数据放到寄存器

167
00:07:00,200 --> 00:07:02,200
然后控制单元

168
00:07:02,200 --> 00:07:04,200
控制什么时候把寄存器的数据

169
00:07:04,200 --> 00:07:06,200
给到计算单元去执行

170
00:07:06,200 --> 00:07:07,200
执行完之后

171
00:07:07,200 --> 00:07:10,200
就把计算单元的结果输出

172
00:07:10,200 --> 00:07:11,200
或者放到寄存器里面

173
00:07:11,200 --> 00:07:13,200
又或者放回内存里面

174
00:07:13,200 --> 00:07:15,200
就是这么简单的一个操作

175
00:07:15,200 --> 00:07:17,200
这么简单的一个架构

176
00:07:17,200 --> 00:07:18,200
沿用至今

177
00:07:18,200 --> 00:07:19,200
CPU的整体架构

178
00:07:19,200 --> 00:07:22,200
基本上就没有太多的变化了

179
00:07:23,200 --> 00:07:24,200
接下来看看

180
00:07:24,200 --> 00:07:26,200
CPU的一个架构图

181
00:07:26,200 --> 00:07:28,200
下面就是整个CPU的架构图

182
00:07:28,200 --> 00:07:29,200
一个简图

183
00:07:30,200 --> 00:07:32,200
首先DRAM就是内存

184
00:07:32,200 --> 00:07:33,200
内存里面之后

185
00:07:33,200 --> 00:07:34,200
有一级的Cache

186
00:07:34,200 --> 00:07:35,200
有二级的Cache

187
00:07:35,200 --> 00:07:38,200
这些其实都可以当做是内存

188
00:07:38,200 --> 00:07:40,200
然后有控制器

189
00:07:40,200 --> 00:07:41,200
真正的执行单元

190
00:07:41,200 --> 00:07:42,200
就是ALU

191
00:07:42,200 --> 00:07:43,200
可以看到

192
00:07:43,200 --> 00:07:45,200
真正执行单元的ALU

193
00:07:45,200 --> 00:07:47,200
占的面积是非常的小的

194
00:07:47,200 --> 00:07:48,200
这里面有四个ALU

195
00:07:48,200 --> 00:07:51,200
假设有四个ALU或者计算盒

196
00:07:51,200 --> 00:07:52,200
在整体电路里面

197
00:07:52,200 --> 00:07:54,200
占的绝大部分的

198
00:07:54,200 --> 00:07:55,200
就是内存

199
00:07:55,200 --> 00:07:56,200
还有控制器

200
00:07:56,200 --> 00:07:58,200
而并非计算

201
00:07:58,200 --> 00:08:00,200
所以说CPU是非常适合

202
00:08:00,200 --> 00:08:03,200
擅长处理逻辑控制

203
00:08:03,200 --> 00:08:04,200
而并非计算

204
00:08:04,200 --> 00:08:06,200
真正你要让计算非常好

205
00:08:06,200 --> 00:08:08,200
所以又有了GPU

206
00:08:08,200 --> 00:08:09,200
有了NPU

207
00:08:09,200 --> 00:08:10,200
这些后话

208
00:08:10,200 --> 00:08:12,200
后面会给大家介绍的

209
00:08:14,200 --> 00:08:15,200
下面来看一下

210
00:08:15,200 --> 00:08:17,200
CPU的约束和限制

211
00:08:17,200 --> 00:08:19,200
实际上计算单元

212
00:08:19,200 --> 00:08:20,200
也就是ALU

213
00:08:20,200 --> 00:08:21,200
逻辑计算单元

214
00:08:21,200 --> 00:08:23,200
它只要是用来完成

215
00:08:23,200 --> 00:08:25,200
整体的数据的计算

216
00:08:25,200 --> 00:08:26,200
其他的模块

217
00:08:26,200 --> 00:08:27,200
包括控制器

218
00:08:27,200 --> 00:08:29,200
为的就是能够

219
00:08:29,200 --> 00:08:30,200
让指令

220
00:08:30,200 --> 00:08:32,200
一条一条有序的去执行

221
00:08:32,200 --> 00:08:33,200
另外方面

222
00:08:33,200 --> 00:08:36,200
还可以提高CPU的主频

223
00:08:36,200 --> 00:08:37,200
也就是提高

224
00:08:37,200 --> 00:08:38,200
单位时间内的

225
00:08:38,200 --> 00:08:40,200
执行指令的条数

226
00:08:40,200 --> 00:08:43,200
来提升整体的计算的速度

227
00:08:43,200 --> 00:08:44,200
传统的CPU

228
00:08:44,200 --> 00:08:45,200
因为这种方式

229
00:08:45,200 --> 00:08:47,200
能够很方便的去写

230
00:08:47,200 --> 00:08:49,200
非常多的应用的代码

231
00:08:49,200 --> 00:08:51,200
不过有一点值得注意的

232
00:08:51,200 --> 00:08:53,200
就是像冯诺依曼架构

233
00:08:53,200 --> 00:08:54,200
这种对指令的

234
00:08:54,200 --> 00:08:56,200
顺序执行的原则

235
00:08:56,200 --> 00:08:58,200
就保证了CPU

236
00:08:58,200 --> 00:09:01,200
每一次只能执行一条指令

237
00:09:01,200 --> 00:09:03,200
会存在多核的情况

238
00:09:03,200 --> 00:09:05,200
一次的话可以执行多条指令

239
00:09:05,200 --> 00:09:07,200
因为原则上

240
00:09:07,200 --> 00:09:09,200
大原则受限于顺序执行

241
00:09:09,200 --> 00:09:11,200
所以计算能力的提升

242
00:09:11,200 --> 00:09:12,200
是受到限制的

243
00:09:12,200 --> 00:09:15,200
于是引入了第二个内容

244
00:09:15,200 --> 00:09:16,200
也就是本节的第二章

245
00:09:16,200 --> 00:09:18,200
并行处理的架构

246
00:09:18,200 --> 00:09:20,200
在并行处理架构里面

247
00:09:20,200 --> 00:09:22,200
主要有四种方式

248
00:09:22,200 --> 00:09:24,200
其实最原始的CPU

249
00:09:24,200 --> 00:09:25,200
就是单指令流

250
00:09:25,200 --> 00:09:27,175
单数据流这种方式

251
00:09:27,175 --> 00:09:27,200
第二种就是SIMD

252
00:09:27,200 --> 00:09:30,175
第二种就是SIMD

253
00:09:30,200 --> 00:09:31,200
现在来说用的最多的

254
00:09:31,200 --> 00:09:32,200
包括现代的CPU

255
00:09:32,200 --> 00:09:33,200
英特尔的

256
00:09:33,200 --> 00:09:34,200
还有AMD的CPU

257
00:09:34,200 --> 00:09:36,200
都是SIMB的架构

258
00:09:36,200 --> 00:09:38,200
而MISD和MIND

259
00:09:38,200 --> 00:09:39,200
反倒用的比较少

260
00:09:39,200 --> 00:09:41,200
下面来看看具体的例子

261
00:09:41,200 --> 00:09:43,200
它们有哪些不一样

262
00:09:43,200 --> 00:09:45,200
下面来到第一个内容

263
00:09:45,200 --> 00:09:48,200
SISD Single Instruction Single Data

264
00:09:48,200 --> 00:09:50,200
PU就是Processing Unit

265
00:09:50,200 --> 00:09:51,200
执行单元

266
00:09:51,200 --> 00:09:53,200
每一次从指令流里面

267
00:09:53,200 --> 00:09:55,200
单独读取一条指令

268
00:09:55,200 --> 00:09:56,200
然后从数据流里面

269
00:09:56,200 --> 00:09:58,200
单独取一条数据

270
00:09:58,200 --> 00:09:59,200
然后进行计算

271
00:09:59,200 --> 00:10:00,200
最后输出

272
00:10:00,200 --> 00:10:02,200
这种方式是串行的去执行的

273
00:10:02,200 --> 00:10:04,200
硬件是不支持并行的方式

274
00:10:04,200 --> 00:10:06,200
而且在每一个时钟周期内

275
00:10:06,200 --> 00:10:09,200
CPU只能够处理一个数据流

276
00:10:09,200 --> 00:10:10,200
举的最简单的例子

277
00:10:10,200 --> 00:10:11,200
就是我的指令

278
00:10:11,200 --> 00:10:13,200
做一个加法的操作

279
00:10:13,200 --> 00:10:15,200
于是我就会在数据流里面

280
00:10:15,200 --> 00:10:17,200
读取两个数据A和B

281
00:10:17,200 --> 00:10:19,200
然后执行一个加法的操作

282
00:10:19,200 --> 00:10:20,200
最后输出一个C

283
00:10:20,200 --> 00:10:21,200
这么简单的

284
00:10:21,200 --> 00:10:23,200
就是SISD

285
00:10:23,200 --> 00:10:24,200
接下来看一下

286
00:10:24,200 --> 00:10:27,200
第二个并行的硬件处理的架构

287
00:10:27,200 --> 00:10:28,200
SIMD

288
00:10:28,200 --> 00:10:30,200
SIMD就有点意思了

289
00:10:30,200 --> 00:10:34,200
就是Single Instruction Multi Data

290
00:10:34,200 --> 00:10:35,200
指令流呢

291
00:10:35,200 --> 00:10:36,200
只有一个指令

292
00:10:36,200 --> 00:10:37,200
但是数据呢

293
00:10:37,200 --> 00:10:38,200
可以有多个数据

294
00:10:38,200 --> 00:10:39,200
从右边的这个图

295
00:10:39,200 --> 00:10:40,200
可以看到

296
00:10:40,200 --> 00:10:42,200
首先读取一条指令

297
00:10:42,200 --> 00:10:45,200
这条指令假设都是加法操作

298
00:10:45,200 --> 00:10:46,200
从数据流里面呢

299
00:10:46,200 --> 00:10:48,200
读取不同的数据出来

300
00:10:48,200 --> 00:10:50,200
最后或许计算并行的去计算

301
00:10:50,200 --> 00:10:53,200
可以看到从左边A1 A2 A3

302
00:10:53,200 --> 00:10:55,200
同时进行一个加法的操作

303
00:10:55,200 --> 00:10:56,200
B1 B2 B3

304
00:10:56,200 --> 00:10:58,200
所以叫做单指令流

305
00:10:58,200 --> 00:11:00,200
多数据的这种方式

306
00:11:00,200 --> 00:11:01,200
加法只有一个

307
00:11:01,200 --> 00:11:02,200
但是数据呢

308
00:11:02,200 --> 00:11:03,200
有很多个

309
00:11:03,200 --> 00:11:04,200
这种的特点呢

310
00:11:04,200 --> 00:11:06,200
就是处理单元非常多

311
00:11:06,200 --> 00:11:07,200
可以看到PU呢

312
00:11:07,200 --> 00:11:08,200
非常多

313
00:11:08,200 --> 00:11:09,200
缺点呢

314
00:11:09,200 --> 00:11:10,200
就是处理的速度呢

315
00:11:10,200 --> 00:11:13,200
会受到计算的通讯的带宽

316
00:11:13,200 --> 00:11:16,200
还有通讯的延时等限制

317
00:11:16,200 --> 00:11:17,200
可以看到最大的限制

318
00:11:17,200 --> 00:11:19,200
就是数据的读取的方式

319
00:11:19,200 --> 00:11:21,200
指令的读取方式是很快的

320
00:11:21,200 --> 00:11:24,200
从寄存器里面去读取指令

321
00:11:24,200 --> 00:11:26,200
数据呢就特别的慢了

322
00:11:26,200 --> 00:11:27,200
接着呢

323
00:11:27,200 --> 00:11:30,200
看一下第三个并行处理架构

324
00:11:30,200 --> 00:11:34,200
就是MISD Multi Instruction and Single Data

325
00:11:34,200 --> 00:11:35,200
这里面呢

326
00:11:35,200 --> 00:11:36,200
多指令流

327
00:11:36,200 --> 00:11:37,200
单数据呢就很有意思

328
00:11:37,200 --> 00:11:39,200
指令流是分开多个的

329
00:11:39,200 --> 00:11:40,200
但是呢

330
00:11:40,200 --> 00:11:43,200
数据只有比较简单的一种

331
00:11:43,200 --> 00:11:45,200
那下面可以看到

332
00:11:45,200 --> 00:11:47,200
左边的这个就是加减层

333
00:11:47,200 --> 00:11:50,200
都有不同的计算的指令

334
00:11:50,200 --> 00:11:51,200
但是呢

335
00:11:51,200 --> 00:11:52,200
输入的数据呢

336
00:11:52,200 --> 00:11:53,200
只有一种最后呢

337
00:11:53,200 --> 00:11:54,200
输出数据

338
00:11:54,200 --> 00:11:55,200
这种呢

339
00:11:55,200 --> 00:11:56,200
其实可以看到

340
00:11:56,200 --> 00:11:57,200
像这种奇奇怪怪的计算

341
00:11:57,200 --> 00:11:59,200
其实我至少从你来看呢

342
00:11:59,200 --> 00:12:00,200
很少能够见到

343
00:12:00,200 --> 00:12:02,200
所以作为一种理论的模型

344
00:12:02,200 --> 00:12:05,200
并没有在实际应用当中去投产的

345
00:12:05,200 --> 00:12:06,200
所以可以看到

346
00:12:06,200 --> 00:12:07,200
类似于这种架构的芯片呢

347
00:12:07,200 --> 00:12:09,200
是非常非常的少

348
00:12:09,200 --> 00:12:11,200
那最后一个就是MIMD了

349
00:12:11,200 --> 00:12:14,200
Multi Instruction Multi Data

350
00:12:14,200 --> 00:12:15,200
在多个数据集上面呢

351
00:12:15,200 --> 00:12:17,200
去执行多个指令流

352
00:12:17,200 --> 00:12:18,200
这种呢

353
00:12:18,200 --> 00:12:20,200
又分为共享内存MIMD

354
00:12:20,200 --> 00:12:22,200
和分布式内存

355
00:12:22,200 --> 00:12:24,200
就分开两种MIMD

356
00:12:24,200 --> 00:12:25,200
一种是共享内存

357
00:12:25,200 --> 00:12:27,200
一种是分布式内存

358
00:12:27,200 --> 00:12:28,200
那现在先看看

359
00:12:28,200 --> 00:12:29,200
共享内存主要是指

360
00:12:29,200 --> 00:12:31,200
在整个CPU

361
00:12:31,200 --> 00:12:33,200
或者在整个芯片系列里面呢

362
00:12:33,200 --> 00:12:35,200
共享所有的全局的内存

363
00:12:35,200 --> 00:12:36,200
而分布式呢

364
00:12:36,200 --> 00:12:40,200
就是跨机器进行内存的共享

365
00:12:40,200 --> 00:12:41,200
而内存共享呢

366
00:12:41,200 --> 00:12:42,200
又可以通过进程间

367
00:12:42,200 --> 00:12:44,200
进行通讯各种方式

368
00:12:44,200 --> 00:12:45,200
但是呢

369
00:12:45,200 --> 00:12:46,200
这种说实话

370
00:12:46,200 --> 00:12:47,200
用的也是比较少的

371
00:12:47,200 --> 00:12:49,200
另外用的更多的

372
00:12:49,200 --> 00:12:51,200
是SIMT

373
00:12:51,200 --> 00:12:52,200
像GPU呢

374
00:12:52,200 --> 00:12:54,200
就是SIMD的

375
00:12:54,200 --> 00:12:55,200
另外一种演进

376
00:12:55,200 --> 00:12:57,200
变成SIMT

377
00:12:57,200 --> 00:13:00,200
把Data变成Flat

378
00:13:00,200 --> 00:13:01,200
变成线程

379
00:13:01,200 --> 00:13:03,200
单指令多线程

380
00:13:03,200 --> 00:13:04,200
右边的这个呢

381
00:13:04,200 --> 00:13:06,200
就是GPU的基本架构

382
00:13:06,200 --> 00:13:07,200
它可以有效的管理和执行

383
00:13:07,200 --> 00:13:10,200
非常非常多的线程

384
00:13:10,200 --> 00:13:11,200
SP呢

385
00:13:11,200 --> 00:13:13,200
就是其中的一个线程执行器

386
00:13:14,200 --> 00:13:15,200
芯片里面呢

387
00:13:15,200 --> 00:13:16,200
就允许一条指令呢

388
00:13:16,200 --> 00:13:19,200
多个数据分开寻址

389
00:13:19,200 --> 00:13:20,200
好了

390
00:13:20,200 --> 00:13:21,200
今天的内容呢

391
00:13:21,200 --> 00:13:22,200
就这么多了

392
00:13:22,200 --> 00:13:23,200
有点水

393
00:13:23,200 --> 00:13:24,200
简单的回顾了一下

394
00:13:24,200 --> 00:13:25,200
CPU的发展历史

395
00:13:25,200 --> 00:13:26,200
它的组成

396
00:13:26,200 --> 00:13:27,200
另外还看了

397
00:13:27,200 --> 00:13:29,200
CPU的并行的架构

398
00:13:29,200 --> 00:13:30,200
从SISD呢

399
00:13:30,200 --> 00:13:32,200
到SIMD到SIMT

400
00:13:32,200 --> 00:13:34,200
它的一个发展的脉络

401
00:13:34,200 --> 00:13:35,200
在接下来的内容

402
00:13:35,200 --> 00:13:36,200
看看

403
00:13:36,200 --> 00:13:37,200
ISA指令集的架构

404
00:13:37,200 --> 00:13:39,200
还有CPU的应用场景

405
00:13:39,200 --> 00:13:40,200
今天内容到这里为止

406
00:13:40,200 --> 00:13:41,200
谢谢各位

407
00:13:41,200 --> 00:13:42,571
拜了个拜

408
00:13:43,078 --> 00:13:44,419
卷的不行了卷的不行了

409
00:13:44,419 --> 00:13:46,175
记得一键三连加关注哦

410
00:13:46,175 --> 00:13:46,200
所有的内容都会开源在下面这条链接里面

411
00:13:46,200 --> 00:13:49,750
所有的内容都会开源在下面这条链接里面

412
00:13:49,775 --> 00:13:51,775
拜了个拜


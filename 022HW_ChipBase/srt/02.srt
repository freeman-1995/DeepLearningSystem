1
00:00:00,000 --> 00:00:04,800
字幕校对:米哈游天下第一

2
00:00:04,800 --> 00:00:08,520
哈喽大家好,我是一周工作猛如虎

3
00:00:08,520 --> 00:00:12,120
拿到手里只有250的ZOMI

4
00:00:12,120 --> 00:00:14,000
一周确实只有 250

5
00:00:14,000 --> 00:00:16,320
低的可怜,职场上卷的不行了

6
00:00:16,320 --> 00:00:19,400
今天还是在 AI 芯片的 AI 芯片

7
00:00:19,400 --> 00:00:21,640
整体的基础看一看 CPU

8
00:00:21,640 --> 00:00:23,880
通用处理器

9
00:00:23,880 --> 00:00:25,480
实际上在通用处理器

10
00:00:25,480 --> 00:00:28,160
上一节已经讲了 CPU 的发展和组成

11
00:00:28,200 --> 00:00:31,520
从而引出了 CPU 的整体的并行的处理架构

12
00:00:31,520 --> 00:00:33,600
今天要主要去聚焦一下

13
00:00:33,600 --> 00:00:35,080
ISA 指令集架构

14
00:00:35,080 --> 00:00:36,800
来去看一看什么是

15
00:00:36,800 --> 00:00:39,920
ISA 所谓的指令集架构

16
00:00:39,920 --> 00:00:43,200
那 ISA 对于整个 CPU GPU

17
00:00:43,200 --> 00:00:46,040
包括到后面的 AI 芯片

18
00:00:46,040 --> 00:00:48,440
它都是非常的重要

19
00:00:48,440 --> 00:00:49,360
知道最后的内容

20
00:00:49,360 --> 00:00:51,920
来回顾一下 CPU 的应用场景

21
00:00:51,920 --> 00:00:53,640
那现在进入到第一个内容

22
00:00:53,640 --> 00:00:55,880
ISA 指令集架构

23
00:00:56,880 --> 00:00:59,640
所谓的 ISA 其实叫做

24
00:00:59,640 --> 00:01:01,640
Instruction Set Architecture

25
00:01:01,640 --> 00:01:04,280
也就是指令集的架构

26
00:01:04,280 --> 00:01:06,280
那 CPU 的全称其实叫做

27
00:01:06,280 --> 00:01:07,600
中央处理器

28
00:01:07,600 --> 00:01:09,640
CPU Center Processing Unit

29
00:01:09,640 --> 00:01:12,160
通常来说区别 CPU 的标准

30
00:01:12,160 --> 00:01:14,240
是指令集的架构

31
00:01:14,240 --> 00:01:15,640
也就是通过指令集架构

32
00:01:15,640 --> 00:01:18,480
去区分 CPU 的一个标准

33
00:01:18,480 --> 00:01:19,960
到底是属于 ARM 的呢

34
00:01:19,960 --> 00:01:22,240
还是属于 x86 的这种不同的体系

35
00:01:22,240 --> 00:01:23,520
当然了指令集架构

36
00:01:23,520 --> 00:01:25,400
包括后面的 GPU、NPU

37
00:01:25,400 --> 00:01:28,000
还有现在的 AI 芯片

38
00:01:28,000 --> 00:01:31,480
都是通过指令集架构去区分的

39
00:01:31,480 --> 00:01:33,320
实际上芯片的开发人员

40
00:01:33,320 --> 00:01:35,080
会基于指令集架构

41
00:01:35,080 --> 00:01:36,480
也就是所谓的 ISA

42
00:01:36,480 --> 00:01:38,800
通过不同的处理器硬件的方案

43
00:01:38,800 --> 00:01:39,800
来去实现的

44
00:01:39,800 --> 00:01:42,560
通过这种 ISA 去设计处理器

45
00:01:42,560 --> 00:01:46,040
因此说 ISA 是作为 CPU 的灵魂

46
00:01:46,040 --> 00:01:48,240
下面这个图就有点意思

47
00:01:48,240 --> 00:01:51,000
是把其中一个 ISA 拿出来

48
00:01:51,000 --> 00:01:52,600
其中一个指令拿出来

49
00:01:52,640 --> 00:01:55,520
那指令集它有很多的指令

50
00:01:55,520 --> 00:02:00,440
MIPS32 它是其中一个 Java 的指令

51
00:02:00,440 --> 00:02:02,680
下面以加法的这个指令

52
00:02:02,680 --> 00:02:03,840
具体打开看看

53
00:02:03,840 --> 00:02:06,480
指令集架构里面的其中一条

54
00:02:07,480 --> 00:02:11,360
首先 MIPS32 它是一个加法的指令

55
00:02:11,360 --> 00:02:13,920
那刚才讲的指令集是一个集合

56
00:02:13,920 --> 00:02:15,080
现在指令集里面

57
00:02:15,080 --> 00:02:17,040
有非常多的不同的指令

58
00:02:17,040 --> 00:02:18,600
而具体的一个指令

59
00:02:18,600 --> 00:02:20,600
是由两个部分来组成的

60
00:02:20,600 --> 00:02:21,720
左边的第一个

61
00:02:21,720 --> 00:02:22,880
就是运算符

62
00:02:22,880 --> 00:02:25,200
告诉现在到底它的 Op Code 是什么

63
00:02:25,200 --> 00:02:27,000
需要进行什么操作

64
00:02:27,000 --> 00:02:28,800
那这里面是以“加”为例子

65
00:02:28,800 --> 00:02:30,720
所以这里面真正的指令

66
00:02:30,720 --> 00:02:32,520
它这是一个加法

67
00:02:32,520 --> 00:02:34,920
右边的这个就是操作数

68
00:02:34,920 --> 00:02:37,160
需要操作的对象

69
00:02:37,160 --> 00:02:39,480
它的参数有三个

70
00:02:39,480 --> 00:02:42,240
R1 是目的操作数

71
00:02:42,240 --> 00:02:44,520
R2 是原操作数

72
00:02:44,520 --> 00:02:46,880
第三个 Immediate Value 是立即数

73
00:02:46,880 --> 00:02:49,440
就是把立即数跟原操作数相加

74
00:02:49,480 --> 00:02:51,800
把得到的结果存到目的操作数

75
00:02:51,800 --> 00:02:54,040
简单的来说就是 Immediate Value

76
00:02:54,040 --> 00:02:57,520
加上 R2 把得到的结果存回 R1

77
00:02:58,440 --> 00:03:00,840
这个就是加法的指令集了

78
00:03:02,160 --> 00:03:03,840
以加法这个指令作为例子

79
00:03:03,840 --> 00:03:06,160
讲完之后看看指令集

80
00:03:06,160 --> 00:03:08,520
其实它有主要的分类有三个

81
00:03:08,520 --> 00:03:10,160
第一个就是运算的指令

82
00:03:10,160 --> 00:03:11,560
那刚才讲到的加法

83
00:03:11,560 --> 00:03:12,960
就是运算指令

84
00:03:12,960 --> 00:03:16,400
在 ALU 当中去执行具体的计算操作

85
00:03:16,400 --> 00:03:19,160
第二种就是数据搬运的一些指令

86
00:03:19,160 --> 00:03:20,600
叫做数据移动指令了

87
00:03:20,600 --> 00:03:24,120
当然它包括大部分的数据的读写 IO

88
00:03:24,120 --> 00:03:25,280
那主要是指这些

89
00:03:25,280 --> 00:03:26,880
第三个对于 CPU 来说

90
00:03:26,880 --> 00:03:28,840
是非常重要的控制指令

91
00:03:28,840 --> 00:03:30,360
就是执行序列

92
00:03:30,360 --> 00:03:31,760
什么时候进行跳转

93
00:03:31,760 --> 00:03:33,560
什么时候 If else while for

94
00:03:33,560 --> 00:03:35,840
这些都属于控制指令

95
00:03:35,840 --> 00:03:37,560
而在这里面剧透一下

96
00:03:37,560 --> 00:03:40,080
 AI 芯片里面

97
00:03:40,080 --> 00:03:43,320
很重要的就是会写自己的一些运算的指令

98
00:03:43,320 --> 00:03:46,200
包括谷歌的 TPU 还有华为昇腾的 NPU

99
00:03:46,200 --> 00:03:48,640
都会有自己独特的运算指令

100
00:03:48,640 --> 00:03:50,920
这就是对应cube核里面

101
00:03:50,920 --> 00:03:53,080
会做的一些特殊的操作

102
00:03:53,080 --> 00:03:56,360
接下来看一下整体的 ISA

103
00:03:56,360 --> 00:03:57,640
指令集架构

104
00:03:57,640 --> 00:03:59,680
它是有一个生命周期的

105
00:03:59,680 --> 00:04:00,520
这个字打错了

106
00:04:00,520 --> 00:04:01,320
不是生命周期

107
00:04:01,320 --> 00:04:02,400
而是生命周期

108
00:04:02,400 --> 00:04:04,640
整体来说它有 6 个生命周期

109
00:04:04,640 --> 00:04:06,040
当然了不是所有的指令

110
00:04:06,040 --> 00:04:07,840
都会循环这个周期

111
00:04:07,840 --> 00:04:08,840
但是这个周期

112
00:04:08,840 --> 00:04:12,520
基本上大原则来说是不会变化的

113
00:04:12,520 --> 00:04:14,360
接下来看第二个内容

114
00:04:14,360 --> 00:04:17,000
就是更宏观的去看看指令集架构了

115
00:04:17,000 --> 00:04:18,560
可以看到指令集架构

116
00:04:18,560 --> 00:04:20,400
主要可以理解为

117
00:04:20,400 --> 00:04:22,360
它是一个抽象的层

118
00:04:22,360 --> 00:04:23,480
属于处理器

119
00:04:23,480 --> 00:04:24,920
底层是硬件

120
00:04:24,920 --> 00:04:28,600
上层是软件连接的一个桥梁

121
00:04:28,600 --> 00:04:30,360
那指令架构刚才讲到了

122
00:04:30,360 --> 00:04:31,120
有计算的指令

123
00:04:31,120 --> 00:04:32,000
数据寻址的指令

124
00:04:32,000 --> 00:04:34,120
还有控制的指令

125
00:04:34,120 --> 00:04:37,120
通过这些去连接好硬件

126
00:04:37,120 --> 00:04:39,040
那硬件可能就会有一些微架构

127
00:04:39,040 --> 00:04:40,680
还有一些 IC 的电路

128
00:04:40,680 --> 00:04:42,080
还有逻辑门

129
00:04:42,080 --> 00:04:44,840
对上就对到机器码了

130
00:04:44,840 --> 00:04:47,080
指令集架构对应的是机器码

131
00:04:47,120 --> 00:04:48,760
对应到机器码之上了

132
00:04:48,760 --> 00:04:50,040
才是编译器

133
00:04:50,040 --> 00:04:52,360
还有一些 symbol 的语言

134
00:04:52,360 --> 00:04:53,960
包括编程语言

135
00:04:53,960 --> 00:04:56,560
在网上编译器网上就是编程语言

136
00:04:56,560 --> 00:04:58,160
再上去就是操作系统

137
00:04:58,160 --> 00:04:58,920
还有算法

138
00:04:58,920 --> 00:04:59,960
还有应用了

139
00:04:59,960 --> 00:05:02,360
它是这么一个具体的组成方式的

140
00:05:02,360 --> 00:05:04,280
所以欢迎大家去我的 GitHub 上面

141
00:05:04,280 --> 00:05:06,200
去取这些内容来看看

142
00:05:06,200 --> 00:05:07,080
去打开这些图

143
00:05:07,080 --> 00:05:08,960
这些图都是每一张都自己画的

144
00:05:14,600 --> 00:05:16,520
讲完 ISA 的一个宏观的概念

145
00:05:16,520 --> 00:05:17,880
有几个问题

146
00:05:17,880 --> 00:05:19,520
那这里面看一下大家懂不懂

147
00:05:19,520 --> 00:05:21,880
或者一起去探讨和思考的

148
00:05:21,880 --> 00:05:24,120
首先就是计算机的架构里面

149
00:05:24,120 --> 00:05:26,200
有多少个寄存器

150
00:05:26,200 --> 00:05:27,400
造个 register 呢

151
00:05:27,400 --> 00:05:30,760
才能够去存放各种各样的指令呢

152
00:05:30,760 --> 00:05:32,760
现在能够进行的

153
00:05:32,760 --> 00:05:34,680
有哪些运算的操作

154
00:05:34,680 --> 00:05:36,160
就有哪些具体的指令

155
00:05:36,160 --> 00:05:38,520
包括加减乘除这些我都知道

156
00:05:38,520 --> 00:05:40,080
但是具体有哪些呢

157
00:05:40,080 --> 00:05:42,120
复杂指令集跟简单指令集之间

158
00:05:42,120 --> 00:05:43,720
又有什么区别呢

159
00:05:43,720 --> 00:05:44,680
第三个问题就是

160
00:05:44,680 --> 00:05:47,040
如果遇到异常或者中断的时候

161
00:05:47,040 --> 00:05:48,440
应该怎么办呢

162
00:05:48,440 --> 00:05:49,560
就刚才指令集

163
00:05:49,560 --> 00:05:51,440
它是有自己的生命周期的

164
00:05:51,440 --> 00:05:53,760
中间整个生命周期被打断了

165
00:05:53,760 --> 00:05:55,280
怎么去执行呀

166
00:05:55,280 --> 00:05:58,320
第四个问题就是数据类型有很多

167
00:05:58,320 --> 00:06:01,000
但数据类型具体有几个字节呢

168
00:06:01,000 --> 00:06:02,520
具体应该怎么存呢

169
00:06:02,520 --> 00:06:03,800
对应指令集架构

170
00:06:03,800 --> 00:06:05,400
又有什么不一样呢

171
00:06:05,400 --> 00:06:06,640
指令集

172
00:06:06,640 --> 00:06:09,080
指令会有长度的嘛

173
00:06:09,080 --> 00:06:10,440
数据类型不一样

174
00:06:10,440 --> 00:06:12,200
那指令是不是长度不一样啊

175
00:06:12,200 --> 00:06:14,400
假设我有一个 int 的加法

176
00:06:14,400 --> 00:06:16,240
跟 float 的加法

177
00:06:16,240 --> 00:06:17,240
指令是两个吗

178
00:06:17,240 --> 00:06:18,200
还是一个

179
00:06:18,200 --> 00:06:20,160
这些问题都非常有意思

180
00:06:20,160 --> 00:06:22,600
非常欢迎大家去弹幕留言

181
00:06:22,600 --> 00:06:24,720
或者去深入地思考

182
00:06:24,720 --> 00:06:26,880
接下来看一下下一个内容

183
00:06:26,880 --> 00:06:28,040
就是 CISC的架构

184
00:06:28,040 --> 00:06:29,320
还有 RISC的架构

185
00:06:29,320 --> 00:06:30,760
那 CISC 的架构呢

186
00:06:30,760 --> 00:06:33,040
就是复杂指令集

187
00:06:33,040 --> 00:06:34,240
而 RISC 架构呢

188
00:06:34,240 --> 00:06:37,040
就是简单的指令集

189
00:06:37,040 --> 00:06:37,920
所谓 CISC

190
00:06:37,920 --> 00:06:39,280
它是一个复杂指令集嘛

191
00:06:39,280 --> 00:06:40,320
除了常用的指令

192
00:06:40,320 --> 00:06:43,120
还有包括非常多不常用的指令

193
00:06:43,120 --> 00:06:44,440
可能常用的指令呢

194
00:06:44,440 --> 00:06:45,760
只占到 20%

195
00:06:45,760 --> 00:06:47,040
80% 的指令呢

196
00:06:47,040 --> 00:06:48,520
都是不常用的

197
00:06:48,520 --> 00:06:49,400
但是没关系

198
00:06:49,400 --> 00:06:51,080
 CPU 的面积呢

199
00:06:51,080 --> 00:06:52,040
可以做得很大

200
00:06:52,040 --> 00:06:53,200
晶体管呢

201
00:06:53,200 --> 00:06:54,920
也可以设计的非常的多

202
00:06:54,920 --> 00:06:56,680
放在笔记本上面呢

203
00:06:56,680 --> 00:06:59,280
其实是还是有很多冗余的地方

204
00:06:59,280 --> 00:07:01,320
所以可以存很多不常用的指令

205
00:07:01,320 --> 00:07:02,320
只要用到的时候

206
00:07:02,320 --> 00:07:04,400
直接把指令调起来就可以用了

207
00:07:04,400 --> 00:07:05,760
这里面可以看到

208
00:07:05,760 --> 00:07:07,440
CISC架构的它的栈呢

209
00:07:07,440 --> 00:07:08,720
是非常的深的

210
00:07:08,720 --> 00:07:10,520
下面看看 RISC 架构

211
00:07:10,520 --> 00:07:11,280
RISC 架构呢

212
00:07:11,320 --> 00:07:13,880
主要只有一些常用的指令

213
00:07:13,880 --> 00:07:14,680
不常用指令呢

214
00:07:14,680 --> 00:07:15,360
它没有

215
00:07:15,360 --> 00:07:17,680
它是用通过一些常用的指令

216
00:07:17,680 --> 00:07:19,080
去做拼接的

217
00:07:19,080 --> 00:07:19,600
当然了

218
00:07:19,600 --> 00:07:20,800
涉及到拼接

219
00:07:20,800 --> 00:07:22,000
它就会衍生了

220
00:07:22,000 --> 00:07:23,160
可能会更慢

221
00:07:23,160 --> 00:07:25,160
本来我在 CPU 上面

222
00:07:25,160 --> 00:07:26,920
在 CISC 架构上面呢

223
00:07:26,920 --> 00:07:28,760
执行一条不常用的指令

224
00:07:28,760 --> 00:07:29,960
可能在RISC 上面呢

225
00:07:29,960 --> 00:07:31,280
要执行五六条

226
00:07:31,280 --> 00:07:33,280
才能够拼起来

227
00:07:33,280 --> 00:07:33,720
现在呢

228
00:07:33,720 --> 00:07:35,320
举一个具体的例子

229
00:07:35,320 --> 00:07:36,640
一个矩阵层

230
00:07:36,640 --> 00:07:38,560
可能在 CISC里面呢

231
00:07:38,560 --> 00:07:40,280
有矩阵层这个指令

232
00:07:40,360 --> 00:07:40,760
但是呢

233
00:07:40,760 --> 00:07:42,240
RISC 里面没有矩阵层

234
00:07:42,240 --> 00:07:44,920
只有单个数据的相乘

235
00:07:44,920 --> 00:07:46,480
单个 scalar 的相乘

236
00:07:46,480 --> 00:07:47,120
这个时候

237
00:07:47,120 --> 00:07:48,720
如果要实现这个操作

238
00:07:48,720 --> 00:07:51,400
可能就要有大量的RISC的这种指令

239
00:07:51,400 --> 00:07:55,160
去组合成为一条一个复杂的矩阵层了

240
00:07:55,160 --> 00:07:55,680
接下来呢

241
00:07:55,680 --> 00:07:57,320
具体的打开一下

242
00:07:57,320 --> 00:08:00,480
CISC架构和 RISC架构具体的不一样

243
00:08:00,480 --> 00:08:02,960
现在先看一下CISC的架构

244
00:08:03,960 --> 00:08:04,880
CISC的架构呢

245
00:08:04,880 --> 00:08:06,680
因为引入了非常多

246
00:08:06,680 --> 00:08:08,520
平时很少用的指令

247
00:08:08,520 --> 00:08:11,280
所以会导致整个 cpu 的设计

248
00:08:11,280 --> 00:08:12,400
包括电路设计

249
00:08:12,400 --> 00:08:13,000
芯片设计

250
00:08:13,000 --> 00:08:14,000
还有软件栈的设计

251
00:08:14,000 --> 00:08:15,800
都会变得非常的复杂

252
00:08:15,800 --> 00:08:16,320
整体呢

253
00:08:16,320 --> 00:08:19,240
增加整个硬件的成本的

254
00:08:19,240 --> 00:08:19,960
除了硬件

255
00:08:19,960 --> 00:08:21,640
还有软件的成本的设计

256
00:08:21,640 --> 00:08:21,920
这样呢

257
00:08:21,920 --> 00:08:23,880
硬件受影响是非常的大的

258
00:08:23,880 --> 00:08:26,320
整体会增加时间研发的成本

259
00:08:26,320 --> 00:08:29,560
还有芯片面积的开销

260
00:08:29,560 --> 00:08:31,000
而像RISC 架构呢

261
00:08:31,000 --> 00:08:33,400
它只包含一些常用的指令

262
00:08:33,400 --> 00:08:34,920
所以经常呢

263
00:08:34,920 --> 00:08:36,040
会在手机端呢

264
00:08:36,040 --> 00:08:37,120
看到手机里面呢

265
00:08:37,160 --> 00:08:38,680
这么小塞一个电源

266
00:08:38,680 --> 00:08:39,640
 cpu 呢

267
00:08:39,640 --> 00:08:41,280
其实非常非常的小

268
00:08:41,280 --> 00:08:41,640
所以呢

269
00:08:41,640 --> 00:08:44,520
非常适合移动端的设备去使用的

270
00:08:44,520 --> 00:08:44,920
当然呢

271
00:08:44,920 --> 00:08:46,280
移动端的设备呢

272
00:08:46,280 --> 00:08:48,680
没办法去做很多复杂的工作

273
00:08:48,680 --> 00:08:50,400
对于现在的应用来说呢

274
00:08:50,400 --> 00:08:52,040
其实已经完全够用了

275
00:08:53,240 --> 00:08:53,640
最后呢

276
00:08:53,640 --> 00:08:54,520
总结了一下

277
00:08:54,520 --> 00:08:57,520
CISC 跟 RISC 的一个具体的区别

278
00:08:57,520 --> 00:08:58,360
我觉得呀

279
00:08:58,360 --> 00:09:01,080
ZOMI觉得最大的区别就是指令的数量

280
00:09:01,080 --> 00:09:02,080
指令的数量

281
00:09:02,080 --> 00:09:05,680
决定了不同的架构之间的区别

282
00:09:05,680 --> 00:09:06,280
第二个呢

283
00:09:06,280 --> 00:09:08,280
就是指令的长度

284
00:09:08,280 --> 00:09:09,920
CISC是不固定长的

285
00:09:09,920 --> 00:09:12,120
而 RISC为了做的更加简单方便

286
00:09:12,120 --> 00:09:15,200
而且非常有明确的约束规范

287
00:09:15,200 --> 00:09:17,160
所以它会是一个定长的

288
00:09:17,160 --> 00:09:19,840
而且可访存的指令呀

289
00:09:19,840 --> 00:09:21,440
CISC 是不加限制的

290
00:09:21,440 --> 00:09:23,480
有非常多各种的访存指令

291
00:09:23,480 --> 00:09:24,600
而在RISC里面呢

292
00:09:24,600 --> 00:09:25,840
只有 Load 和 Store

293
00:09:25,840 --> 00:09:26,520
而这里面呢

294
00:09:26,520 --> 00:09:28,720
提到这个访存指令呢

295
00:09:28,720 --> 00:09:30,320
就提到 ai 芯片了

296
00:09:30,320 --> 00:09:32,160
ai 芯片的访存的方式

297
00:09:32,160 --> 00:09:33,120
是跟 cpu

298
00:09:33,120 --> 00:09:34,520
跟 gpu 不一样的

299
00:09:34,560 --> 00:09:36,200
所以 ai 芯片呢

300
00:09:36,200 --> 00:09:38,200
用的是一个CISC的架构

301
00:09:38,200 --> 00:09:38,680
这里面呢

302
00:09:38,680 --> 00:09:41,040
要澄清一点就是指令级架构

303
00:09:41,040 --> 00:09:42,840
虽然是从 cpu 衍生过来

304
00:09:42,840 --> 00:09:43,320
但是呢

305
00:09:43,320 --> 00:09:44,640
可以反推过去

306
00:09:44,640 --> 00:09:46,920
它不一定只代表 CISC

307
00:09:46,920 --> 00:09:49,680
就是针对 cpu 才能够设计的

308
00:09:49,680 --> 00:09:51,200
可能 ai 芯片里面

309
00:09:51,200 --> 00:09:53,000
也可以用到 CISC 的架构

310
00:09:53,000 --> 00:09:53,920
ai 芯片里面

311
00:09:53,920 --> 00:09:56,920
也或许会用到 RISC的架构

312
00:09:56,920 --> 00:09:57,440
具体呢

313
00:09:57,440 --> 00:09:58,880
后面讲 ai 芯片的时候

314
00:09:58,880 --> 00:10:00,640
还会深入的去打开

315
00:10:01,960 --> 00:10:02,480
最后呢

316
00:10:02,480 --> 00:10:04,080
就是ISA的种类了

317
00:10:04,120 --> 00:10:04,960
刚才说到

318
00:10:04,960 --> 00:10:06,440
因为 cpu 的发展

319
00:10:06,440 --> 00:10:08,800
衍生了非常多不同的架构

320
00:10:08,800 --> 00:10:09,920
而整体 cpu 呢

321
00:10:09,920 --> 00:10:13,400
实际上是在 1960 年开始正式的问世

322
00:10:13,400 --> 00:10:16,600
之前讲到第一台大型的 cpu

323
00:10:16,600 --> 00:10:18,000
那种是大型的 cpu

324
00:10:18,000 --> 00:10:20,200
现在讲到的是微型的 cpu

325
00:10:20,200 --> 00:10:20,800
这些呢

326
00:10:20,800 --> 00:10:22,760
都是在 60 年代问世的

327
00:10:22,760 --> 00:10:25,080
已经发展了五六十年了

328
00:10:25,080 --> 00:10:26,720
而这五六十年代里面呢

329
00:10:26,720 --> 00:10:27,880
出现了

330
00:10:27,880 --> 00:10:31,000
又消亡了非常多不同的架构

331
00:10:31,000 --> 00:10:32,280
现在用过的最多的是

332
00:10:32,280 --> 00:10:34,160
 x86 的指令架构

333
00:10:34,160 --> 00:10:34,840
英特尔呢

334
00:10:34,840 --> 00:10:37,040
AMD都是使用 x86

335
00:10:37,040 --> 00:10:39,240
现在买机器买服务器

336
00:10:39,240 --> 00:10:40,240
都使用 x86

337
00:10:40,240 --> 00:10:41,320
而现在呢

338
00:10:41,320 --> 00:10:42,040
ARM 呢

339
00:10:42,040 --> 00:10:43,600
用的非常的多

340
00:10:43,600 --> 00:10:44,480
无处不在了

341
00:10:44,480 --> 00:10:45,600
我现在的手机

342
00:10:45,600 --> 00:10:47,120
包括现在的嵌入式设备

343
00:10:47,120 --> 00:10:49,080
都是用 ARM 这个指令架构的

344
00:10:49,080 --> 00:10:49,920
而后面呢

345
00:10:49,920 --> 00:10:51,320
应该是最近

346
00:10:51,320 --> 00:10:54,720
又有了 RISC-V 这种开放式指令

347
00:10:54,720 --> 00:10:55,240
那当然了

348
00:10:55,240 --> 00:10:56,200
这种开放式指令呢

349
00:10:56,200 --> 00:10:57,240
现在来说

350
00:10:57,240 --> 00:10:59,440
开始慢慢的涌现的越来越多了

351
00:10:59,440 --> 00:11:00,960
因为 ARM 它是收费的

352
00:11:00,960 --> 00:11:02,160
x86 也是收费的

353
00:11:02,160 --> 00:11:02,880
而且 x86 呢

354
00:11:02,880 --> 00:11:04,640
还是真不完全对外公开

355
00:11:04,640 --> 00:11:06,680
而 ARM 是公开授权的

356
00:11:06,680 --> 00:11:07,640
而RISC-V 呢

357
00:11:07,640 --> 00:11:08,960
现在越来越多人的参与

358
00:11:08,960 --> 00:11:10,600
是因为它是完全开放的

359
00:11:10,600 --> 00:11:11,000
所以呢

360
00:11:11,000 --> 00:11:11,920
可以给 RISC-V 呢

361
00:11:11,920 --> 00:11:13,760
做更多各种各样的

362
00:11:13,760 --> 00:11:15,920
新的芯片的设计

363
00:11:15,920 --> 00:11:16,600
那最后呢

364
00:11:16,600 --> 00:11:17,640
还有一些已经消亡

365
00:11:17,640 --> 00:11:19,280
或者已经用的越来越少的

366
00:11:19,280 --> 00:11:20,240
一些指令架构了

367
00:11:20,240 --> 00:11:22,520
就不一一介绍了

368
00:11:22,520 --> 00:11:23,400
接下来看看

369
00:11:23,400 --> 00:11:25,720
整体的 CPU 的应用场景

370
00:11:25,720 --> 00:11:27,200
这个就相当于废话了

371
00:11:27,200 --> 00:11:29,120
大家简单的了解一下就好了

372
00:11:29,120 --> 00:11:30,840
现在 CPU 应用的最多的

373
00:11:30,840 --> 00:11:32,560
肯定是服务器领域

374
00:11:32,560 --> 00:11:35,040
但他个人可能接触的比较少

375
00:11:35,040 --> 00:11:36,680
但是现在我国有各种

376
00:11:36,680 --> 00:11:38,520
大量的云运营商

377
00:11:38,520 --> 00:11:39,240
华为云

378
00:11:39,240 --> 00:11:39,960
百度云

379
00:11:39,960 --> 00:11:40,920
阿里云

380
00:11:40,920 --> 00:11:42,160
还有腾讯云

381
00:11:42,160 --> 00:11:43,360
这些云服务商啊

382
00:11:43,360 --> 00:11:45,960
都是用大量的服务器领域的

383
00:11:45,960 --> 00:11:47,240
里面塞了大量的

384
00:11:47,240 --> 00:11:48,880
x86 的 CPU 在里面

385
00:11:48,880 --> 00:11:49,440
那第二个呢

386
00:11:49,440 --> 00:11:51,600
就是平时经常接触到的

387
00:11:51,600 --> 00:11:53,360
包括我给你们录视频的这个

388
00:11:53,360 --> 00:11:54,920
都是用苹果电脑

389
00:11:54,920 --> 00:11:55,960
能用到电脑了

390
00:11:55,960 --> 00:11:58,720
就会用到 Intel 和 AMD 的芯片

391
00:11:58,720 --> 00:11:59,200
当然了

392
00:11:59,200 --> 00:12:00,080
现在苹果呢

393
00:12:00,080 --> 00:12:01,840
基于 ARM 确实开发出

394
00:12:01,840 --> 00:12:03,360
自己的 PC 领域的芯片

395
00:12:03,360 --> 00:12:04,800
这也是跟 Intel 打架打得

396
00:12:04,800 --> 00:12:06,640
非常厉害的一个话题咯

397
00:12:06,640 --> 00:12:08,360
那最后就是嵌入式领域了

398
00:12:08,360 --> 00:12:10,400
包括手机嵌入式的设备

399
00:12:10,400 --> 00:12:13,080
包括经常之前疫情期间呢

400
00:12:13,080 --> 00:12:14,400
滴的一声扫一扫

401
00:12:14,400 --> 00:12:15,360
那种都是

402
00:12:15,360 --> 00:12:18,400
IOS 嵌入式的设备

403
00:12:18,400 --> 00:12:20,440
最后来一个总结

404
00:12:20,440 --> 00:12:21,600
就是现在呢

405
00:12:21,600 --> 00:12:23,320
CPU 是具备整体的

406
00:12:23,320 --> 00:12:24,720
图灵的完备性的

407
00:12:24,720 --> 00:12:25,440
控制器呢

408
00:12:25,440 --> 00:12:27,320
主动的从内存里面

409
00:12:27,320 --> 00:12:28,440
读取指令流

410
00:12:28,440 --> 00:12:29,680
读取数据

411
00:12:29,720 --> 00:12:30,360
然后呢

412
00:12:30,360 --> 00:12:32,200
解码之后给计算机

413
00:12:32,200 --> 00:12:33,200
计算单元

414
00:12:33,200 --> 00:12:34,680
ALU 进行执行

415
00:12:34,680 --> 00:12:35,320
那最后呢

416
00:12:35,320 --> 00:12:37,360
再把结果写回数据

417
00:12:37,360 --> 00:12:38,040
那第二个呢

418
00:12:38,040 --> 00:12:40,000
讲了 ISA

419
00:12:40,000 --> 00:12:40,960
 ISA 呢

420
00:12:40,960 --> 00:12:42,640
主要是跟计算机

421
00:12:42,640 --> 00:12:43,280
体系结构

422
00:12:43,280 --> 00:12:44,680
还有编程部分相关的

423
00:12:44,680 --> 00:12:46,320
它定义了整个指令集的

424
00:12:46,320 --> 00:12:47,280
数据类型计算器

425
00:12:47,280 --> 00:12:47,800
寻址

426
00:12:47,800 --> 00:12:48,360
内存管理

427
00:12:48,360 --> 00:12:49,240
还有 IO

428
00:12:49,240 --> 00:12:51,960
所以说 ISA 对于 CPU 来说

429
00:12:51,960 --> 00:12:53,720
非常非常的重要

430
00:12:53,720 --> 00:12:54,320
没了它

431
00:12:54,320 --> 00:12:56,400
就没有了现在的 CPU

432
00:12:57,240 --> 00:12:57,840
最后一点呢

433
00:12:57,840 --> 00:12:59,480
实际上可以把 CPU 呢

434
00:12:59,480 --> 00:13:00,840
简单的分开为

435
00:13:00,840 --> 00:13:02,040
控制面

436
00:13:02,040 --> 00:13:03,440
还有计算面

437
00:13:03,440 --> 00:13:04,280
两个部分

438
00:13:04,280 --> 00:13:04,840
而 CPU 呢

439
00:13:04,840 --> 00:13:07,160
作为指令流驱动的

440
00:13:07,160 --> 00:13:08,720
整体的计算引擎

441
00:13:08,720 --> 00:13:10,160
非常的重要

442
00:13:10,160 --> 00:13:10,800
现在来说

443
00:13:10,800 --> 00:13:12,040
做任何事情

444
00:13:12,040 --> 00:13:14,000
都离不开 CPU

445
00:13:14,000 --> 00:13:16,240
包括现在虽然有 AI 芯片

446
00:13:16,240 --> 00:13:18,600
但是 AI 芯片要跟 CPU 配合来使用

447
00:13:18,600 --> 00:13:19,880
更多的调度控制

448
00:13:19,880 --> 00:13:21,640
是由 CPU 来做的

449
00:13:21,640 --> 00:13:23,520
而具体的可能矩阵的计算

450
00:13:23,520 --> 00:13:24,840
和深度学习的计算

451
00:13:24,840 --> 00:13:25,640
AI 的计算

452
00:13:25,640 --> 00:13:26,640
就交给

453
00:13:26,640 --> 00:13:28,280
具体的其他的芯片

454
00:13:28,280 --> 00:13:29,360
而总体来说

455
00:13:29,360 --> 00:13:30,600
CPU 很重要

456
00:13:30,600 --> 00:13:31,080
于是呢

457
00:13:31,080 --> 00:13:32,040
就放在第一节

458
00:13:32,040 --> 00:13:32,920
那今天的内容呢

459
00:13:32,920 --> 00:13:33,680
就到这里为止

460
00:13:33,680 --> 00:13:34,240
谢谢各位

461
00:13:34,240 --> 00:13:35,320
拜了个拜

462
00:13:36,160 --> 00:13:36,920
卷的不行了

463
00:13:36,920 --> 00:13:37,800
卷的不行了

464
00:13:37,800 --> 00:13:39,640
记得一键三连加关注哦

465
00:13:39,640 --> 00:13:40,400
所有的内容

466
00:13:40,400 --> 00:13:41,240
都会开源在

467
00:13:41,240 --> 00:13:43,200
下面这条链接里面

468
00:13:43,200 --> 00:13:44,000
拜了个拜

